- [Vai al file Principale](../../README.md)

# 1 Lezione 17 settembre 2025

√® come i software comunicano tra di loro -> attraverso che canali

Architetture software -> ambiente dove viene sviluppata e per cosa e perch√® ambiente di sviluppo
Server -> deve accedere a un db
con immagini -> file system

React -> solo frontend

## COme si cambia inforazione tra Backend e F<rontend

Attraverso API -> legge come JSON
COndivido con team -> come sviluppare un software

Capire come fare per lavorare con il team come concetton un backend e con il frontend

Frontend -> layout non APPI -> frontend gestisce grafica

## üîπ Cos‚Äô√® la scalabilit√†

La **scalabilit√†** √® la capacit√† di un sistema (sito web, applicazione, piattaforma) di:

- gestire un aumento del numero di utenti o richieste,
- elaborare pi√π dati,
- mantenere alte le prestazioni **senza blocchi o rallentamenti**.

In altre parole, se oggi il tuo sito gestisce 100 utenti contemporanei e domani deve gestirne 10.000, un sistema scalabile deve riuscirci senza dover essere riscritto da zero.

## üîπ Tipi di scalabilit√†

1. **Scalabilit√† verticale (scale up)**

   - Aggiungi pi√π risorse al **singolo server** (pi√π RAM, CPU pi√π potente, dischi pi√π veloci).
   - Limite: il server non pu√≤ crescere all‚Äôinfinito.

2. **Scalabilit√† orizzontale (scale out)**

   - Aggiungi pi√π server che lavorano insieme (cluster, cloud, container).
   - Puoi gestire teoricamente utenti infiniti, distribuendo il carico.

## üîπ Aggiornamento in tempo reale

Per avere un sistema che si aggiorna **in tempo reale** (es. chat, dashboard dati, notifiche live), si usano tecnologie come:

- **WebSocket** ‚Üí connessione continua tra client e server (es. usato in chat, giochi online, trading).
- **Server-Sent Events (SSE)** ‚Üí il server invia aggiornamenti in streaming al browser.
- **Polling / Long Polling** ‚Üí il client chiede continuamente nuovi dati (meno efficiente).

Esempio: se stai gestendo una **dashboard con dati di sensori IoT**, con WebSocket ogni aggiornamento arriva all‚Äôutente senza ricaricare la pagina.

## üîπ Gestione grandi quantit√† di dati

Un sito scalabile deve saper gestire anche **Big Data**. Alcune pratiche comuni:

- **Database distribuiti** (MongoDB, Cassandra, PostgreSQL cluster) ‚Üí i dati non stanno in un solo server, ma vengono distribuiti.
- **Caching** (Redis, Memcached) ‚Üí memorizzi i dati pi√π richiesti per evitare calcoli continui.
- **CDN (Content Delivery Network)** ‚Üí distribuisci contenuti statici (immagini, video, file) su server in tutto il mondo.
- **Microservizi** ‚Üí invece di avere un‚Äôunica app enorme (monolite), dividi in pi√π servizi indipendenti (es. autenticazione, gestione ordini, notifiche).

## üîπ Schema tipico di un sistema scalabile

1. **Frontend (utente)** ‚Üí sito web o app mobile.
2. **Backend (API)** ‚Üí server con logica di business.
3. **Database distribuito** ‚Üí per salvare dati.
4. **Load Balancer** ‚Üí distribuisce il carico su pi√π server.
5. **Cache** ‚Üí per risposte veloci.
6. **WebSocket / SSE** ‚Üí per aggiornamenti in tempo reale.
7. **Cloud (AWS, Azure, GCP)** ‚Üí per scalare automaticamente in base al traffico.

## Scalabilit√†

- Verticale -> aggiungi RAM, CPU, dischi
- Orizzontale -> aggiungi server, cluster -> gestisco in automatico e risponde con il metodo pi√π veloce

## Resiliente

Capacit√† di riprendersi velocemente deve essere full-tollerence disponibile anche a errori quando non va -> funziona su altro server senza bloccare appp e deve essere funzionante anche in caso di crash

- Monoliti -> pi√π app -> pi√π server -> cambio una cosa devo cambiare tutto l'app

- Applicazione 3 modo

  - Dati
  - Business
  - Presentazione

## üîπ Definizione di Microservizi

I **microservizi** sono un‚Äôarchitettura software in cui un‚Äôapplicazione non √® costruita come un **monolite unico**, ma come un insieme di **piccoli servizi indipendenti**, ognuno con una funzione specifica.
Diversi strumenti che sono collegsti tra di loro e fanno applicativo

Sequenza di informazioni -> che ognuno ha la sua funzione specifica -> che comunicano tra di loro -> evento scatena evento che da funzionali√† -> guidato da eventi

üëâ Ogni microservizio:

- √® **autonomo** (pu√≤ essere sviluppato, aggiornato e distribuito indipendentemente dagli altri),
- ha il proprio **database** o la propria gestione dei dati,
- comunica con gli altri microservizi tramite **API** (spesso REST o gRPC, a volte con sistemi di messaggistica come RabbitMQ o Kafka).

## üîπ Caratteristiche principali

- **Indipendenza** ‚Üí se devo aggiornare il sistema di pagamento, lavoro solo sul microservizio ‚Äúpagamenti‚Äù, senza toccare login o catalogo prodotti.
- **Scalabilit√† mirata** ‚Üí posso scalare solo il microservizio che riceve pi√π traffico (es. ‚Äúricerca‚Äù), senza sprecare risorse sugli altri.
- **Affidabilit√†** ‚Üí se un microservizio cade, il resto del sistema continua a funzionare.
- **Team specializzati** ‚Üí ogni team pu√≤ lavorare su un microservizio diverso (es. un team su ‚Äúnotifiche‚Äù, un altro su ‚Äúautenticazione‚Äù).

- Pi√π team -> pi√π servizi -> pi√π costi e pi√π strumenti e attivit√†
  - Diversi strumenti -> possono avere anche tecnologie diverse

## üîπ Esempio pratico

Immagina un sito di e-commerce:

- **Microservizio Utenti** ‚Üí gestisce registrazione/login.
- **Microservizio Prodotti** ‚Üí gestisce catalogo e magazzino.
- **Microservizio Pagamenti** ‚Üí gestisce ordini e transazioni.
- **Microservizio Notifiche** ‚Üí invia email o SMS.

Se devo modificare il metodo di pagamento, cambio solo il microservizio ‚ÄúPagamenti‚Äù, senza toccare gli altri.

## üîπ Vantaggi rispetto al monolite

- ‚úÖ Aggiornamenti pi√π rapidi.
- ‚úÖ Scalabilit√† mirata.
- ‚úÖ Resilienza maggiore.
- ‚úÖ Tecnologie miste (ogni microservizio pu√≤ essere scritto in un linguaggio diverso).

## HTTP

Hyber Text Transfer Protocol -> protocolo di comunicazione tra client e server per il web per tasportare pagine web e dati

- Header
  - Content-type
  - cookie

## Metodi HTTP

### üîπ **GET**

- **Definizione:** Recupera dati dal server (solo lettura).
- **Path (esempio):**

  - `GET /users` ‚Üí lista di tutti gli utenti
  - `GET /users/1` ‚Üí dettaglio utente con id=1

- **Aggiorna?** ‚ùå No

### üîπ **POST**

- **Definizione:** Crea una nuova risorsa.
- **Path (esempio):**

  - `POST /users` ‚Üí crea un nuovo utente

- **Aggiorna?** ‚úîÔ∏è S√¨, aggiunge

### üîπ **PUT**

- **Definizione:** Aggiorna **completamente** una risorsa (sostituisce tutti i campi).
- **Path (esempio):**

  - `PUT /users/1` ‚Üí aggiorna _tutti_ i dati dell‚Äôutente con id=1

- **Aggiorna?** ‚úîÔ∏è S√¨, ma con sostituzione totale

### üîπ **PATCH**

- **Definizione:** Aggiorna **parzialmente** una risorsa (solo alcuni campi).
- **Path (esempio):**

  - `PATCH /users/1` ‚Üí aggiorna _solo i campi specificati_ dell‚Äôutente con id=1

- **Aggiorna?** ‚úîÔ∏è S√¨, ma solo parziale

### üîπ **DELETE**

- **Definizione:** Elimina una risorsa.
- **Path (esempio):**

  - `DELETE /users/1` ‚Üí elimina l‚Äôutente con id=1

- **Aggiorna?** ‚úîÔ∏è S√¨, rimuove

üìå **Riassunto tabella**

| Metodo     | Definizione                          | Path esempio         | Aggiorna?                     |
| ---------- | ------------------------------------ | -------------------- | ----------------------------- |
| **GET**    | Legge i dati (read-only)             | `/users`, `/users/1` | ‚ùå                            |
| **POST**   | Crea una nuova risorsa               | `/users`             | ‚úîÔ∏è (aggiunge)                 |
| **PUT**    | Aggiorna **tutta** la risorsa        | `/users/1`           | ‚úîÔ∏è (sostituisce tutto)        |
| **PATCH**  | Aggiorna **parzialmente** la risorsa | `/users/1`           | ‚úîÔ∏è (modifica campi specifici) |
| **DELETE** | Elimina una risorsa                  | `/users/1`           | ‚úîÔ∏è (cancella)                 |

## LoadBalancer

Bilancia il carico quando i server sono troppo carichi -> con algoritmi
Dei loadbalancer -> misurano e gestiscono il carico.

## üîπ **Cos‚Äô√® un Reverse Proxy**

Un **reverse proxy** √® un server che sta ‚Äúin mezzo‚Äù tra i client (es. browser, app frontend) e i server backend (API, database, microservizi).
Riceve le richieste dal client e le **inoltra al server giusto**, gestendo il traffico e spesso aggiungendo funzionalit√† utili.

## üîπ **Funzioni principali di un Reverse Proxy**

- üõ† **Integrazione frontend-backend** ‚Üí permette al frontend di parlare con il backend senza problemi di porte, CORS o sicurezza.
- üîí **Sicurezza** ‚Üí nasconde i server backend, filtra richieste malevole, gestisce certificati HTTPS.
- ‚ö° **Load balancing** ‚Üí distribuisce il carico tra pi√π server backend per migliorare le prestazioni.
- üì¶ **Caching** ‚Üí pu√≤ salvare in memoria alcune risposte per rispondere pi√π velocemente.
- üö™ **Single entry point** ‚Üí il client fa sempre richiesta a un unico indirizzo (es. `https://api.miosito.it`) e il reverse proxy smista al backend corretto.

---

## üîπ Schema semplice

```
[ Browser / Frontend ] ---> [ Reverse Proxy ] ---> [ Backend 1 ]
                                             ---> [ Backend 2 ]
                                             ---> [ Backend N ]
```

## CDN

I **CDN (Content Delivery Network)** hanno proprio lo scopo di trasferire **meno dati possibili** nel modo pi√π efficiente.

Ecco perch√©:

1. **Distribuzione geografica**
   I file statici (immagini, CSS, JS, video, ecc.) vengono copiati su pi√π server sparsi nel mondo. L‚Äôutente scarica i contenuti dal server pi√π vicino, riducendo tempi e quantit√† di trasferimento.

2. **Caching**
   Una volta scaricato un file, il browser lo conserva in cache. Se il file non cambia, non viene riscaricato, ma riutilizzato. Questo significa meno dati trasferiti ad ogni visita.

3. **Compressione automatica**
   Molti CDN applicano **gzip o Brotli** ai file testuali (HTML, CSS, JS), riducendo la dimensione dei dati trasferiti.

4. **Ottimizzazione immagini e video**
   Alcuni CDN adattano automaticamente le immagini al dispositivo (risoluzione, formato WebP/AVIF), trasferendo solo i byte realmente necessari.

5. **Minificazione e concatenazione**
   Possono fornire versioni **minificate** di CSS e JS, eliminando spazi e caratteri inutili, cos√¨ che il browser scarichi meno dati.

CDN -> crei da server -> ma senza header e cookie -> tempo di cache alto -> peschi CDN pi√π veloce a lui e server pi√π veloce degli altri

CDN -> calcoli con lapda -> pi√π veloce a utente finale -> distribuito su tutto e fornisce header -> maantenere dati cache browser -> non scarichi ma solo dati nuovi

## üìå Perch√© utili i microservizi?

- **Posso utilizzare il codice in pi√π pezzi**
  ‚Üí riutilizzabilit√† e modularit√†.

- **Se non funziona uno, rifai solo quello, non tutto**
  ‚Üí isolamento dei problemi, manutenzione pi√π semplice.

- **Pi√π risorse ‚Üí pi√π tempo**
  ‚Üí ogni microservizio pu√≤ essere scalato indipendentemente in base alle necessit√†.

- **Pi√π difficile da ristrutturare (se monolitico)**
  ‚Üí i microservizi evitano di dover riscrivere l‚Äôintera applicazione.

- **Design curato in base a singoli componenti**
  ‚Üí progettazione modulare, ogni parte ha un compito chiaro.

- **Scelta delle tecnologie pi√π adatte**
  ‚Üí ogni microservizio pu√≤ essere sviluppato con linguaggi diversi.

- **Aggiornamenti rapidi e indipendenti**
  ‚Üí si possono fare release pi√π veloci senza bloccare tutto.

- **Capacit√† di scalling**
  ‚Üí si possono aggiungere server in base alle necessit√†, aggiungi macchine o togli server in base alle necessit√†.

- **Monitoraggio dati**
  ‚Üí si possono monitorare in tempo reale le risorse e le prestazioni -> e capire quanto usi e costi.

## üîó Come comunicare con i microservizi

I microservizi possono comunicare principalmente in due modi: **code/eventi** o **sessioni/sincrono**.

### **1. Comunicazione tramite code (asincrona)**

- Un microservizio invia un **messaggio** a una coda (es. RabbitMQ, Kafka).
- Il microservizio destinatario **riceve il messaggio** e lo elabora in base alle opzioni richieste.
- **Operazioni asincrone**: il mittente non deve aspettare che il destinatario finisca subito.
- **Gestione dei tempi**: se il servizio non √® disponibile, il messaggio resta nella coda fino a elaborazione.
- **Configurazione necessaria**: devi impostare e gestire l‚Äôambiente di messaggistica.

### **2. Comunicazione tramite sessioni (sincrona)**

- Il microservizio mittente **invoca direttamente** il servizio destinatario tramite API (es. REST, gRPC).
- Il mittente **aspetta la risposta** (operazione sincrona).
- Adatto per operazioni **immediate** o quando serve una conferma rapida.
- **Svantaggio**: se il destinatario √® lento o non disponibile, il mittente rimane bloccato.

* **Sessioni**: implementatate e gestite

### üîë Sintesi dei vantaggi/uso:

| Tipo         | Quando usarlo               | Pro                                      | Contro                                |
| ------------ | --------------------------- | ---------------------------------------- | ------------------------------------- |
| Code/eventi  | Operazioni asincrone, batch | Non blocca, resiliente, gestione ritardi | Configurazione pi√π complessa          |
| Sessioni/API | Operazioni immediate        | Semplice, risposta diretta               | Bloccante se il servizio non risponde |

## üîê Autenticazione e logout

I microservizi e le applicazioni web richiedono **autenticazione** per garantire accesso sicuro e **logout** per proteggere le sessioni.

### **1. Autenticazione con password**

- **Funzionamento:** l‚Äôutente inserisce **username e password** per accedere.
- **Gestione sicurezza:** le password devono essere **hashate e salate** per evitare furti.
- **Sessione:** l‚Äôaccesso viene gestito tramite **sessioni** o **token**.
- **Logout:** chiude la sessione, impedendo accessi non autorizzati.
- **Pro:** semplice da implementare, comune.
- **Contro:** vulnerabile a furto di password o attacchi phishing.

### **2. Autenticazione con chiavette o app dedicate**

- **Funzionamento:** si usa un **dispositivo fisico** (chiavetta USB tipo YubiKey) o un‚Äô**app di autenticazione** (OTP, QR code).
- **2FA:** spesso combinata con la password (**autenticazione a due fattori**) per maggiore sicurezza.
- **Sessione:** l‚Äôaccesso richiede il dispositivo/app; logout funziona come per le password.
- **Pro:** molto sicuro, protegge anche se la password viene rubata.
- **Contro:** pi√π complesso da gestire, serve un dispositivo aggiuntivo.

### üîë Differenze principali tra i due metodi

| Caratteristica               | Password         | Chiavetta/App (2FA)                                         |
| ---------------------------- | ---------------- | ----------------------------------------------------------- |
| Tipo di autenticazione       | Solo credenziali | Credenziali + dispositivo/app                               |
| Sicurezza                    | Base             | Alta                                                        |
| Complessit√† gestione         | Bassa            | Alta                                                        |
| Protezione da furto password | No               | S√¨                                                          |
| Logout                       | Chiude sessione  | Chiude sessione, richiede nuovo accesso con dispositivo/app |

### ‚úÖ Sintesi

- **Password:** semplice ma meno sicura.
- **Chiavette/App:** pi√π sicura, richiede dispositivo aggiuntivo, ideale per dati sensibili.
- **Logout:** fondamentale in entrambi i casi per proteggere la sessione.

### **Sessioni e Autenticazione**

1. **Stateless Authentication (Autenticazione senza stato)**

   - Il server **non memorizza alcuna informazione sull'utente** tra le richieste.
   - Ogni richiesta deve contenere **tutte le informazioni necessarie per autenticare l‚Äôutente**.
   - Vantaggi: scalabilit√† pi√π facile, meno carico sul server.
   - Svantaggi: gestione dei token e sicurezza possono diventare pi√π complesse.

2. **JWT Token (JSON Web Token)**

   - Un **token crittografato** che contiene informazioni sull‚Äôutente (payload) e una firma per verificarne l‚Äôautenticit√†.
   - Utilizzato principalmente nelle **autenticazioni stateless**.
   - Ogni richiesta invia il token, che il server verifica senza dover consultare il database delle sessioni.
   - Esempio di uso: login -> ricevo JWT -> lo invio nell‚Äôheader `Authorization: Bearer <token>` ad ogni richiesta.

3. **Session Stores distribuiti**

   - Quando si vuole mantenere lo stato della sessione, ma avere pi√π server che gestiscono le richieste, si usa un **archivio esterno** (es. Redis, Memcached).
   - Il server salva la sessione dell‚Äôutente nello store distribuito e legge da l√¨ ogni volta che serve.
   - Utile in ambienti scalabili e clusterizzati.

4. **OAuth e SSO (Single Sign-On)**

   - **OAuth**: protocollo per consentire a un‚Äôapplicazione di accedere a risorse su un altro servizio senza condividere la password.

     - Es: login con Google/Facebook su un sito terzo.

   - **SSO**: sistema che permette di fare **login una sola volta** e accedere a pi√π servizi senza reinserire le credenziali.

     - Spesso implementato usando OAuth, SAML o OpenID Connect.

## ‚úÖ Pro e ‚ùå contro microservizi

| ‚úÖ **Pro**                                                                                         | ‚ùå **Contro**                                                                                 |
| -------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| ‚ö° **Scalabilit√† indipendente** ‚Äì Ogni servizio si pu√≤ scalare separatamente.                      | üåê **Overhead di comunicazione** ‚Äì La rete pu√≤ introdurre latenza e problemi di affidabilit√†. |
| üõ†Ô∏è **Manutenibilit√† e modularit√†** ‚Äì Codice pi√π chiaro e facile da aggiornare.                     | üß© **Complessit√† architetturale** ‚Äì Gestire tanti servizi separati √® pi√π complesso.           |
| üöÄ **Deploy rapido e flessibile** ‚Äì Aggiornamenti locali senza fermare l‚Äôintera app.               | üß™ **Test pi√π complessi** ‚Äì L‚Äôintegrazione tra servizi richiede pi√π strumenti.                |
| üåà **Tecnologie eterogenee** ‚Äì Ogni microservizio pu√≤ usare il linguaggio migliore per il compito. | üíæ **Gestione dati difficile** ‚Äì Coordinare transazioni tra servizi √® complicato.             |
| üõ°Ô∏è **Resilienza** ‚Äì Un servizio che fallisce non blocca tutto.                                     | üìä **Monitoraggio e distribuzione** ‚Äì Serve infrastruttura avanzata per gestire i servizi.    |
| üë• **Team autonomi** ‚Äì Squadre diverse possono lavorare indipendentemente.                         | üí∞ **Costi infrastrutturali maggiori** ‚Äì Pi√π servizi richiedono pi√π risorse e server.         |

## **OAuth (Open Authorization)**

**Definizione:**
OAuth √® un **protocollo di autorizzazione** che permette a un‚Äôapp di accedere a dati di un utente su un altro servizio **senza chiedere la password** dell‚Äôutente.

**Come funziona in breve:**

1. L‚Äôutente autorizza l‚Äôapp a usare alcuni dati su un altro servizio (es. Google, Facebook).
2. Il servizio fornisce un **token di accesso** all‚Äôapp, con permessi limitati.
3. L‚Äôapp usa il token per accedere solo ai dati consentiti, senza mai vedere la password dell‚Äôutente.

**Esempio pratico:**

- ‚ÄúAccedi con Google‚Äù ‚Üí il sito riceve un token, legge solo le informazioni consentite (es. email, nome), e tu non dai la tua password al sito.

## Architettura dei Servizi Distribuiti

## Coordinamento dei servizi

Il coordinamento dei servizi garantisce che i componenti di un sistema distribuito possano comunicare in modo efficiente e resiliente.

### Service Discovery

- I servizi si trovano a vicenda automaticamente, senza configurazioni manuali.
- Favorisce scalabilit√† e gestione dinamica dei servizi.

### Circuit Breakers

- Interrompe le chiamate verso un servizio non disponibile o in errore.
- Previene l‚Äôeffetto a catena e aumenta la resilienza del sistema.

### Retry Patterns

- Ripete automaticamente le richieste fallite.
- Spesso implementato con ritardi progressivi (_exponential backoff_).

### Timeout Strategies

- Definisce un tempo massimo di attesa per una risposta.
- Evita blocchi e rallentamenti del sistema.

## Scambio di messaggi

Permette ai servizi di comunicare tra loro, in modalit√† **sincrona** o **asincrona**.

### Sincrono

- La richiesta del client attende la risposta del server.
- Tipico delle API REST.

### Asincrono

- La comunicazione non richiede una risposta immediata.
- I messaggi vengono elaborati in background, migliorando il decoupling e la resilienza.

### REST APIs

- Interfacce HTTP standard (GET, POST, PUT, DELETE) per scambiare dati.
- Vantaggi: semplicit√† e compatibilit√†.
- Svantaggi: pi√π chiamate necessarie per dati correlati.

### GraphQL

- Linguaggio di query per API che permette di richiedere **solo i dati necessari**.
- Riduce sovraccarichi e chiamate multiple.
- Ideale per sistemi complessi con entit√† correlate.

### Message Brokers

- Sistemi intermediari per la gestione dei messaggi tra servizi.
- Garantisce **affidabilit√†, buffering e decoupling**.
- Esempi:
  - **RabbitMQ**: code di messaggi, routing complesso e conferma di ricezione.
  - **Kafka**: stream di dati ad alto throughput, ideale per elaborazioni in tempo reale.

## üåê Utilizzo Strumenti (AWS, Azure, GCP, ecc.)

Quando si usano piattaforme cloud come **Amazon Web Services (AWS)**, **Microsoft Azure** o **Google Cloud Platform (GCP)**, √® fondamentale **gestire bene i costi e le risorse**.

### üîë Buone pratiche:

- **Porsi dei limiti di prezzo**

  - Impostare un _budget mensile_ e usare gli strumenti di monitoraggio dei costi integrati (es. AWS Budgets, Azure Cost Management, GCP Billing).
  - Ricevere _alert_ se si supera una certa soglia di spesa.

- **Limitare le risorse delle macchine**

  - Quando crei una macchina virtuale o un servizio, puoi definire i **limiti di CPU, RAM e storage**.
  - In questo modo eviti di consumare troppo e far crescere i costi senza controllo.

- **Autoscaling controllato**

  - Attivare lo _scaling automatico_, ma con soglie massime: cos√¨ l‚Äôapp cresce solo fino a un certo punto e non oltre.

- **Spegnere risorse non usate**

  - Se una macchina virtuale non serve 24/7, meglio spegnerla o usare servizi _serverless_ che paghi solo quando li usi.

- **Monitoraggio costante**

  - Tenere d‚Äôocchio dashboard e report per capire dove stai spendendo di pi√π e se puoi ottimizzare.

### üîë Caratteristiche principali:

- **Tolleranza agli errori** ‚Üí non si blocca se qualcosa va storto, ma gestisce le eccezioni in modo controllato.
- **Stabilit√†** ‚Üí continua a funzionare anche sotto carico elevato o con risorse limitate.
- **Resilienza** ‚Üí si riprende velocemente dopo un malfunzionamento o un guasto.
- **Affidabilit√†** ‚Üí garantisce risultati consistenti e corretti nel tempo.
- **Sicurezza** ‚Üí protegge i dati e previene comportamenti indesiderati anche in caso di input errati o attacchi.

### **Applicazione Robusta**

Un‚Äôapplicazione si definisce **robusta** quando √® **affidabile, resistente agli errori e capace di funzionare correttamente anche in condizioni impreviste o avverse**.
